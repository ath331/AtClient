////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  NetworkWorker Class
////////////////////////////////////////////////////////////////////////////////////////////////////


#include "Network/NetworkWorker.h"
#include "Sockets.h"
#include "Serialization/ArrayWriter.h"
#include "PacketSession.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  생성자
////////////////////////////////////////////////////////////////////////////////////////////////////
RecvWorker::RecvWorker( FSocket* Socket, TSharedPtr< PacketSession > Session ) :
	Socket( Socket ), SessionWPtr( Session )
{
	Thread = FRunnableThread::Create( this, TEXT( "RecvWorkerThread" ) );
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  소멸자
////////////////////////////////////////////////////////////////////////////////////////////////////
RecvWorker::~RecvWorker()
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  초기화 한다
////////////////////////////////////////////////////////////////////////////////////////////////////
bool RecvWorker::Init()
{
	GEngine->AddOnScreenDebugMessage( -1, 5.f, FColor::Red, FString::Printf( TEXT( "RecvWorkerThread Init" ) ) );
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  실행한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 RecvWorker::Run()
{
	while ( Running )
	{
		TArray< uint8 > Packet;

		if ( ReceivePacket( OUT Packet ) )
		{
			if ( TSharedPtr< PacketSession > Session = SessionWPtr.Pin() )
			{
				Session->RecvPacketQueue.Enqueue( Packet );
			}
		}
	}

	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  종료한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
void RecvWorker::Exit()
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  스레드를 멈춘다.
////////////////////////////////////////////////////////////////////////////////////////////////////
void RecvWorker::Destroy()
{
	Running = false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  패킷을 수신한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool RecvWorker::ReceivePacket( TArray<uint8>& OutPacket )
{
	// 패킷 헤더 파싱
	const int32 HeaderSize = sizeof( FPacketHeader );
	TArray< uint8 > HeaderBuffer;
	HeaderBuffer.AddZeroed( HeaderSize );

	if ( ReceiveDesiredBytes( HeaderBuffer.GetData(), HeaderSize ) == false )
		return false;

	// ID, Size 추출
	FPacketHeader Header;
	{
		FMemoryReader Reader( HeaderBuffer );
		Reader << Header;
		UE_LOG( LogTemp, Log, TEXT( "Recv PacketID : %d, PacketSize : %d" ), Header.PacketID, Header.PacketSize );
	}

	// 패킷 헤더 복사
	OutPacket = HeaderBuffer;

	// 패킷 내용 파싱
	TArray< uint8 > PayloadBuffer;
	const int32 PayloadSize = Header.PacketSize - HeaderSize;
	OutPacket.AddZeroed( PayloadSize );

	if ( ReceiveDesiredBytes( &OutPacket[ HeaderSize ], PayloadSize ) )
		return true;

	return false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  패킷 크기만큼의 수신을 대기한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool RecvWorker::ReceiveDesiredBytes( uint8* Results, int32 Size )
{
	uint32 PendingDataSize;
	if ( !Socket->HasPendingData( PendingDataSize ) || PendingDataSize <= 0 )
		return false;

	int32 Offset = 0;

	while ( Size > 0 )
	{
		int32 NumRead = 0;
		Socket->Recv( Results + Offset, Size, OUT NumRead );
		check( NumRead <= Size );

		if ( NumRead <= 0 )
			return false;

		Offset += NumRead;
		Size   -= NumRead;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  생성자
////////////////////////////////////////////////////////////////////////////////////////////////////
SendWorker::SendWorker( FSocket* Socket, TSharedPtr< class PacketSession > Session ) : 
	Socket( Socket ), SessionWPtr( Session )
{
	Thread = FRunnableThread::Create( this, TEXT( "SendWorkerThread" ) );
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  소멸자
////////////////////////////////////////////////////////////////////////////////////////////////////
SendWorker::~SendWorker()
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  초기화한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool SendWorker::Init()
{
	GEngine->AddOnScreenDebugMessage( -1, 5.f, FColor::Red, FString::Printf( TEXT( "Send Thread Init" ) ) );

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  실행한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 SendWorker::Run()
{
	while ( Running )
	{
		SendBufferPtr SendBuffer;

		if ( TSharedPtr< PacketSession > Session = SessionWPtr.Pin() )
		{
			if ( Session->SendPacketQueue.Dequeue( OUT SendBuffer ) )
			{
				SendPacket( SendBuffer );
			}
		}
	}

	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  종료한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
void SendWorker::Exit()
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  패킷을 전송한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool SendWorker::SendPacket( SendBufferPtr SendBuffer )
{
	if ( !SendDesiredBytes( SendBuffer->Buffer(), SendBuffer->WriteSize() ) )
		return false;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  스레드를 멈춘다.
////////////////////////////////////////////////////////////////////////////////////////////////////
void SendWorker::Destroy()
{
	Running = false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// @brief  size만큼 Buffer를 전송한다.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool SendWorker::SendDesiredBytes( const uint8* Buffer, int32 Size )
{
	while ( Size > 0 )
	{
		int32 BytesSent = 0;
		if ( !Socket->Send( Buffer, Size, BytesSent ) )
			return false;

		Size   -= BytesSent;
		Buffer += BytesSent;
	}

	return true;
}
